blogdown:::new_post_addin()
library(dagitty); library(ggdag); library(tidyverse)
dag <- dagitty("dag {
sales [outcome, pos=\"0,0\"]
mkt [exposure, pos=\"2,0\"]
comp [pos=\"1,1\"]
visits [pos=\"1,0\"]
visits -> sales
mkt -> visits
comp -> mkt
comp -> sales
}")
ggdag(dag)
# dag - an object of class "dagitty" representing the variable DAG
# g.args - named list. Each element name denotes the child node name. Each elementt is a list with optional arguments:
## link: "identity"/"quadratic". This is the link function.
## levels: positive integer. 1 indicates continuous. 2 and above indicate the number of levels in a categorical variable
## labels: categorical variable labels. Need to be have length equal to levels
## betas: a list. Each element name indicate parent variable. Each element contains vector of beta coefficients
# N number of samples to generate
simMixedDAG <- function(dag, g.args,  N = 1000){
g <- function(vars, link = "identity", levels = 1, betas = NULL, labels = NULL){
if(!link %in% c("identity", "quadratic", "cosin")) stop("argument link in g.args has to be one of identity, quadratic, cosin")
lp <- rep(0, N)
for(i in seq_along(vars)){
var_val <- try(eval(parse(text = vars[i]), envir = parent.frame(1L)), silent = T)
if(class(var_val) == "try-error"){
assign(vars[i], do.call(g, append(list(vars = parents[[vars[i]]]), g.args[[vars[i]]])), envir = pos.to.env(-1L))
var_val <- eval(parse(text = vars[i]))
}
if(is.null(betas)){
beta <- as.matrix(if(is.factor(var_val)) rnorm(length(levels(var_val))) else rnorm(1))
} else {
beta <- as.matrix(betas[[vars[i]]])
}
X <- model.matrix(~ var_val - 1)
if(ncol(X) != nrow(beta)) stop(paste0("Number of levels in ", vars[i], "does not match number of input betas for that variable"))
lp <- lp + as.numeric(X %*% beta)
}
if(link == "quadratic") lp <- sign(lp)*lp^2
if(link == "cosin") lp <- cos(lp*2)
lp <- lp + rnorm(length(lp))
lp <- lp/sd(lp)
if(levels > 1){
thresh <- qnorm(seq(0, 1, length.out = levels + 1))
lp <- cut(lp, breaks = thresh, labels = if(is.null(labels)) LETTERS[1:levels] else labels, include.lowest = T)
}
return(lp)
}
parents <- setNames(lapply(names(dag), function(var) dagitty::parents(dag, var)), names(dag))
vars <- names(parents)
for(i in seq_along(names(parents))){
if(!exists(vars[i])){
assign(vars[i], do.call(g, append(list(vars = parents[[vars[i]]]), g.args[[vars[i]]])), envir = pos.to.env(-1L))
}
}
return(setNames(data.frame(lapply(vars, function(var) eval(parse(text = var)))), vars))
}
g.args <- list(mkt = list(betas = list(comp = 0.6)), visits = list(betas = list(mkt = 0.5)),
sales = list(betas = list(visits = 0.3, comp = -0.9)))
sim_data <- simMixedDAG(dag, g.args)
sim_data %>% ggplot(aes(comp, mkt)) + geom_point() + stat_smooth(method = "lm")
g.args <- list(mkt = list(betas = list(comp = 1.1), link = "cosin"), visits = list(betas = list(mkt = 0.5)),
sales = list(betas = list(visits = 0.3, comp = -0.9)))
sim_data <- simMixedDAG(dag, g.args)
sim_data %>% ggplot(aes(comp, mkt)) + geom_point() + stat_smooth()
g.args <- list(mkt = list(betas = list(comp = 0.6)), visits = list(betas = list(mkt = 0.5)),
sales = list(betas = list(visits = 0.3, comp = -0.9), link = "quadratic"))
sim_data <- simMixedDAG(dag, g.args)
sim_data %>% ggplot(aes(comp, sales)) + geom_point() + stat_smooth()
g.args <- list()
sim_data <- simMixedDAG(dag, g.args)
sim_data %>% ggplot(aes(comp, sales)) + geom_point()
g.args <- list(mkt = list(betas = list(comp = 0.6)), visits = list(betas = list(mkt = 0.5), levels = 3),
sales = list(betas = list(visits = c(-0.3, 0, 0.2), comp = -0.9)))
g.args <- list(mkt = list(betas = list(comp = 0.6)), visits = list(betas = list(mkt = 0.5), levels = 3),
sales = list(betas = list(visits = c(-0.3, 0), comp = -0.9)))
sim_data <- simMixedDAG(dag, g.args)
library(dagitty)
?simulateSEM
library(lavaan)
?simulateData
library(bnlearn)
?bnlearn::rbn
?bn
?gs
?ais
library(dagitty); library(ggdag); library(tidyverse)
dag <- dagitty("dag {
sales [outcome, pos=\"0,0\"]
mkt [exposure, pos=\"2,0\"]
comp [pos=\"1,1\"]
visits [pos=\"1,0\"]
visits -> sales
mkt -> visits
comp -> mkt
comp -> sales
}")
ggdag(dag)
# dag - an object of class "dagitty" representing the variable DAG
# g.args - named list. Each element name denotes the child node name. Each elementt is a list with optional arguments:
## link: "identity"/"quadratic". This is the link function.
## levels: positive integer. 1 indicates continuous. 2 and above indicate the number of levels in a categorical variable
## labels: categorical variable labels. Need to be have length equal to levels
## betas: a list. Each element name indicate parent variable. Each element contains vector of beta coefficients
# N number of samples to generate
simMixedDAG <- function(dag, g.args,  N = 1000){
g <- function(vars, link = "identity", levels = 1, betas = NULL, labels = NULL){
if(!link %in% c("identity", "quadratic", "cosin")) stop("argument link in g.args has to be one of identity, quadratic, cosin")
lp <- rep(0, N)
for(i in seq_along(vars)){
var_val <- try(eval(parse(text = vars[i]), envir = parent.frame(1L)), silent = T)
if(class(var_val) == "try-error"){
assign(vars[i], do.call(g, append(list(vars = parents[[vars[i]]]), g.args[[vars[i]]])), envir = pos.to.env(-1L))
var_val <- eval(parse(text = vars[i]))
}
if(is.null(betas)){
beta <- as.matrix(if(is.factor(var_val)) rnorm(length(levels(var_val))) else rnorm(1))
} else {
beta <- as.matrix(betas[[vars[i]]])
}
X <- model.matrix(~ var_val - 1)
if(ncol(X) != nrow(beta)) stop(paste0("Number of levels in ", vars[i], " does not match number of input betas for that variable"))
lp <- lp + as.numeric(X %*% beta)
}
if(link == "quadratic") lp <- sign(lp)*lp^2
if(link == "cosin") lp <- cos(lp*2)
lp <- lp + rnorm(length(lp))
lp <- (lp-mean(lp))/sd(lp)
if(levels > 1){
thresh <- qnorm(seq(0, 1, length.out = levels + 1))
lp <- cut(lp, breaks = thresh, labels = if(is.null(labels)) LETTERS[1:levels] else labels, include.lowest = T)
}
return(lp)
}
parents <- setNames(lapply(names(dag), function(var) dagitty::parents(dag, var)), names(dag))
vars <- names(parents)
for(i in seq_along(names(parents))){
if(!exists(vars[i])){
assign(vars[i], do.call(g, append(list(vars = parents[[vars[i]]]), g.args[[vars[i]]])), envir = pos.to.env(-1L))
}
}
return(setNames(data.frame(lapply(vars, function(var) eval(parse(text = var)))), vars))
}
g.args <- list(mkt = list(betas = list(comp = 0.6)), visits = list(betas = list(mkt = 0.5)),
sales = list(betas = list(visits = 0.3, comp = -0.9)))
sim_data <- simMixedDAG(dag, g.args)
sim_data %>% ggplot(aes(comp, mkt)) + geom_point() + stat_smooth(method = "lm")
g.args <- list(mkt = list(betas = list(comp = 1.1), link = "cosin"), visits = list(betas = list(mkt = 0.5)),
sales = list(betas = list(visits = 0.3, comp = -0.9)))
sim_data <- simMixedDAG(dag, g.args)
lm(mkt ~ comp, data = sim_data) %>% coef()
library(dagitty); library(ggdag); library(tidyverse)
dag <- dagitty("dag {
sales [outcome, pos=\"0,0\"]
mkt [exposure, pos=\"2,0\"]
comp [pos=\"1,1\"]
visits [pos=\"1,0\"]
visits -> sales
mkt -> visits
comp -> mkt
comp -> sales
}")
ggdag(dag)
# dag - an object of class "dagitty" representing the variable DAG
# g.args - named list. Each element name denotes the child node name. Each elementt is a list with optional arguments:
## link: "identity"/"quadratic". This is the link function.
## levels: positive integer. 1 indicates continuous. 2 and above indicate the number of levels in a categorical variable
## labels: categorical variable labels. Need to be have length equal to levels
## betas: a list. Each element name indicate parent variable. Each element contains vector of beta coefficients
# N number of samples to generate
simMixedDAG <- function(dag, g.args,  N = 1000){
g <- function(vars, link = "identity", levels = 1, betas = NULL, labels = NULL){
if(!link %in% c("identity", "quadratic", "cosin")) stop("argument link in g.args has to be one of identity, quadratic, cosin")
lp <- rep(0, N)
for(i in seq_along(vars)){
var_val <- try(eval(parse(text = vars[i]), envir = parent.frame(1L)), silent = T)
if(class(var_val) == "try-error"){
assign(vars[i], do.call(g, append(list(vars = parents[[vars[i]]]), g.args[[vars[i]]])), envir = pos.to.env(-1L))
var_val <- eval(parse(text = vars[i]))
}
if(is.null(betas)){
beta <- as.matrix(if(is.factor(var_val)) rnorm(length(levels(var_val))) else rnorm(1))
} else {
beta <- as.matrix(betas[[vars[i]]])
}
X <- model.matrix(~ var_val - 1)
if(ncol(X) != nrow(beta)) stop(paste0("Number of levels in ", vars[i], " does not match number of input betas for that variable"))
lp <- lp + as.numeric(X %*% beta)
}
if(link == "quadratic") lp <- sign(lp)*lp^2
if(link == "cosin") lp <- cos(lp*2)
lp <- lp + rnorm(length(lp))
lp <- (lp-mean(lp))/sd(lp)
if(levels > 1){
thresh <- qnorm(seq(0, 1, length.out = levels + 1))
lp <- cut(lp, breaks = thresh, labels = if(is.null(labels)) LETTERS[1:levels] else labels, include.lowest = T)
}
return(lp)
}
parents <- setNames(lapply(names(dag), function(var) dagitty::parents(dag, var)), names(dag))
vars <- names(parents)
for(i in seq_along(names(parents))){
if(!exists(vars[i])){
assign(vars[i], do.call(g, append(list(vars = parents[[vars[i]]]), g.args[[vars[i]]])), envir = pos.to.env(-1L))
}
}
return(setNames(data.frame(lapply(vars, function(var) eval(parse(text = var)))), vars))
}
g.args <- list(mkt = list(betas = list(comp = 0.6)), visits = list(betas = list(mkt = 0.5)),
sales = list(betas = list(visits = 0.3, comp = -0.9)))
sim_data <- simMixedDAG(dag, g.args)
sim_data %>% ggplot(aes(comp, mkt)) + geom_point() + stat_smooth(method = "lm")
lm(mkt ~ comp, data = sim_data) %>% coef()
options(scipen = 999)
lm(mkt ~ comp, data = sim_data) %>% coef()
sim_data <- simMixedDAG(dag, g.args, N = 10000)
sim_data %>% ggplot(aes(comp, mkt)) + geom_point() + stat_smooth(method = "lm")
lm(mkt ~ comp, data = sim_data) %>% coef()
sim_data <- simMixedDAG(dag, g.args)
sim_data %>% ggplot(aes(comp, mkt)) + geom_point() + stat_smooth(method = "lm")
g.args <- list(mkt = list(betas = list(comp = 1.1), link = "cosin"), visits = list(betas = list(mkt = 0.5)),
sales = list(betas = list(visits = 0.3, comp = -0.9)))
sim_data <- simMixedDAG(dag, g.args)
sim_data %>% ggplot(aes(comp, mkt)) + geom_point() + stat_smooth()
g.args <- list(mkt = list(betas = list(comp = 0.6)), visits = list(betas = list(mkt = 0.5)),
sales = list(betas = list(visits = 0.3, comp = -0.9), link = "quadratic"))
sim_data <- simMixedDAG(dag, g.args)
sim_data %>% ggplot(aes(comp, sales)) + geom_point() + stat_smooth()
g.args <- list()
sim_data <- simMixedDAG(dag, g.args)
sim_data %>% ggplot(aes(comp, sales)) + geom_point()
g.args <- list(mkt = list(betas = list(comp = 0.6)), visits = list(betas = list(mkt = 0.5), levels = 3),
sales = list(betas = list(visits = c(-0.3, 0), comp = -0.9)))
sim_data <- simMixedDAG(dag, g.args)
sim_data %>% ggplot(aes(visits, sales)) + geom_boxplot()
g.args <- list(mkt = list(betas = list(comp = 0.6)), visits = list(betas = list(mkt = 0.5), levels = 3),
sales = list(betas = list(visits = c(-0.3, 0), comp = -0.9)))
sim_data <- simMixedDAG(dag, g.args)
g.args <- list(mkt = list(betas = list(comp = 0.6)), visits = list(betas = list(mkt = 0.5), levels = 3),
sales = list(betas = list(visits = c(-0.3, 0, 0.2), comp = -0.9)))
sim_data <- simMixedDAG(dag, g.args)
sim_data %>% ggplot(aes(visits, sales)) + geom_boxplot()
a = read.csv("../../../../../../Downloads/CIMSEmpowerment_2018-2019YTD.csv")
a %>% View()
