} else {
beta <- as.matrix(betas[[var]])
}
X <- model.matrix(~ var_val - 1)
if(is.factor(var_val)) X <- X[, -1]
if(ncol(X) != nrow(beta)) stop(paste0("Number of levels in \"", var, "\" does not match number of input betas for that variable"))
lp <- lp + as.numeric(X %*% beta)
}
if(link == "quadratic") lp <- sign(lp)*lp^2
if(link == "cosin") lp <- cos(lp*2)
if(link == "exp") lp <- exp(lp)-1
if(var(lp) == 0){
lp <- lp + rnorm(length(lp), sd = 1) # add noise
} else {
lp <- lp + rnorm(length(lp), sd = sqrt(var(lp)/sinr)) # add noise
}
if(levels > 1){
if(is.null(labels)) labels <- LETTERS[1:levels]
if(length(labels) != levels) stop(paste0("labels do not match levels argument for variable \"", result_var, "\""))
lp <- lp/sd(lp)
thresh <- qnorm(p = seq(0, 1, length.out = levels + 1))
lp <- cut(lp, breaks = thresh, labels = labels, include.lowest = T)
}
return(lp)
}
for(var in vars){
if(!exists(var, envir = env)){
assign(var, do.call(f, append(list(vars = parents[[var]], env = env, result_var = var), f.args[[var]])), envir = env)
}
}
return(setNames(data.frame(lapply(vars, function(var) eval(parse(text = var)))), vars))
}
###################
get_ate <- function(dag_model, ...) UseMethod("get_ate")
get_ate.parametric_dag_model <- function(dag_model,  treatment = NULL, treatment_vals = NULL, exposure = NULL, N = 1000, M = 1000){
dag <- dag_model$dag; f.args <- dag_model$f.args
if(f.args[[exposure]]$levels > 2) stop("Exposure must be either numeric (levels = 1) or binary (levels = 2)")
if(is.null(treatment_vals)){
if(f.args[[treatment]]$levels == 1){
sample_treatment <- sim_mixed_dag(dag_model)[[treatment]]
treatment_vals <- unname(quantile(sample_treatment, seq(0.05, 0.95, by = 0.3)))
} else {
treatment_vals <- f.args[[treatment]]$labels
}
}
results <- matrix(ncol = length(treatment_vals), nrow = M)
ans <- data.frame(treatment_value = treatment_vals, ate = NA)
vars <- names(dag); vars <- vars[vars != treatment]
parents <- setNames(lapply(vars, function(var) dagitty::parents(dag, var)), vars)
env <- environment()
for(i in 1:length(treatment_vals)){
treatment_ls = setNames(list(rep(treatment_vals[i], N)), nm = treatment)
for(m in 1:M){
sim_data <- do.call(sim_mixed_dag, list(dag_model = dag_model, N = N, treatment_list = treatment_ls))
results[m, i] <- mean(sim_data[[exposure]])
}
}
ans$ate <- c(NA, diff(apply(results, 2, mean)))
return(ans)
}
####################
g <- dagitty("dag {
sales [pos=\"0,0\"]
mkt [pos=\"2,0\"]
comp [pos=\"1,1\"]
visits [pos=\"1,0\"]
visits -> sales
mkt -> visits
comp -> mkt
comp -> sales
}")
dag_model <- parametric_dag_model(dag = g, f.args = list(sales = list(betas = list(visits = 0.3, comp = -0.9)),
visits = list(betas = list(mkt = 0.5)),
mkt = list(betas = list(comp = 0.6))))
sim_data <- sim_mixed_dag(dag_model, N = 1432)
sim_data %>% ggplot(aes(comp, sales)) + geom_point() + stat_smooth(method = "lm")
# ate <- get_ate(dag_model = dag_model, treatment = "mkt", treatment_vals = seq(-2, 2), exposure = "sales")
# print(ate)
####################
non_parametric_dag_model <- function(dag, data){
if(mean(names(dag) %in% names(data)) != 1) stop("Some DAG nodes not found in data")
if(any(is.na(data))) stop("data contains missing values")
data <- data[names(dag)]
data <- data %>% mutate_if(is.character, factor) %>%
mutate_if(function(x) length(unique(x)) == 2, factor) # code 2 value variables as binary
vars <- names(dag)
ans <- setNames(object = vector(mode = "list", length = length(vars)), nm = vars)
for(var in vars){
var_parents <- parents(dag, var)
if(length(var_parents) == 0){
ans[[var]]$node_type <- "parentless"
sampling_vals <- tapply(data[[var]], data[[var]], length)/length(data[[var]])
sampling_vals <- data.frame(value = names(sampling_vals), freq = sampling_vals, row.names = NULL, stringsAsFactors = F)
if(is.numeric(data[[var]])) sampling_vals$value = as.numeric(sampling_vals$value)
ans[[var]]$sampling_vals <- sampling_vals
ans[[var]]$target_levels <- if(is.factor(data[[var]])) levels(data[[var]]) else NULL
} else {
ans[[var]]$parents <- var_parents
if(class(data[[var]]) == "factor") {
ans[[var]]$node_type <- "categorical"
forms <- lapply(unlist(strsplit(paste0(var, paste0(rep(paste0(" ~ ", paste0(sapply(var_parents, function(var_parent) {
if(class(data[[var_parent]]) == "factor") return(var_parent) else return(paste0("s(", var_parent, ")"))
}), collapse = " + ")), length(levels(data[[var]])) - 1), collapse = ", ")), ",")), as.formula)
ans[[var]]$target_levels <- levels(data[[var]])
num_levels <- length(levels(data[[var]]))
dat <- data[c(var, var_parents)]; dat[[var]] <- as.integer(dat[[var]]) - 1
ans[[var]]$gam_model <- gam(forms, family = if(num_levels == 2) "binomial" else multinom(K = num_levels - 1), data = dat)
} else {
ans[[var]]$node_type <- "continuous"
form <- as.formula(paste0(var, " ~ ", paste0(sapply(var_parents, function(var_parent) {
if(class(data[[var_parent]]) == "factor") return(var_parent) else return(paste0("s(", var_parent, ")"))
}), collapse = " + ")))
dat <- data[c(var, var_parents)]
ans[[var]]$gam_model <- gam(formula = form, family = "gaussian", data = dat)
ans[[var]]$gam_model$sd <- sd(dat[[var]])
}
}
}
ans <- list(dag = dag, gam_fits = ans)
class(ans) <- "non_parametric_dag_model"
return(ans)
}
#####################
sim_mixed_dag.non_parametric_dag_model <- function(dag_model,  N = 1000){
dag <- dag_model$dag; gam_fits <- dag_model$gam_fits
if(mean(names(gam_fits) %in% names(dag)) != 1 | length(names(dag)) != length(names(gam_fits))) stop("some variable entries in gam_fits don't match node names in supplied DAG")
env <- environment()
vars <- names(dag)
library(gam); library(mgcv)
f_parentless <- function(sampling_vals, target_levels = NULL, N) {
ans <- sample(x = sampling_vals[[1]], size = N, replace = T, prob = sampling_vals[[2]])
if(!is.null(target_levels)) ans <- factor(ans, levels = target_levels)
return(ans)
}
f_categorical <- function(gam_model, target_levels, parents, N, env){
newdata <- list()
for(parent in parents){
newdata[[parent]] <- try(eval(parse(text = parent), envir = env), silent = T)
if(class(newdata[[parent]]) == "try-error"){
if(gam_fits[[parent]]$node_type == "parentless"){
assign(parent, do.call(f_parentless, list(sampling_vals = gam_fits[[parent]]$sampling_vals, N = N,
target_levels = gam_fits[[parent]]$target_levels), envir = env), pos = env)
} else if(gam_fits[[parent]]$node_type == "categorical") {
assign(parent, do.call(f_categorical, list(gam_model = gam_fits[[parent]]$gam_model,
parents = gam_fits[[parent]]$parents,
target_levels = gam_fits[[parent]]$target_levels,
N = N,
env = env), envir = env), pos = env)
} else if(gam_fits[[parent]]$node_type == "continuous"){
assign(parent, do.call(f_cont, list(gam_model = gam_fits[[parent]]$gam_model,
parents = gam_fits[[parent]]$parents,
target_levels = gam_fits[[parent]]$target_levels,
N = N,
env = env), envir = env), pos = env)
}
newdata[[parent]] <- eval(parse(text = parent), envir = env)
}
}
newdata <- as.data.frame(newdata) %>% mutate_all(list(~replace(., is.na(.), sample(x = ., size = sum(is.na(.)), replace = T)))) # this shouldn't be needed
pred <- predict(gam_model, newdata, type = "response")
if(length(target_levels) == 2) {
return(target_levels[sapply(pred, function(p) rbinom(1, 1, p))])
} else {
return(factor(target_levels[apply(pred, 1, function(p_vec) which(rmultinom(1, 1, p_vec) == 1))], levels = target_levels))
}
}
f_cont <- function(gam_model, parents, N, env){
newdata <- list()
for(parent in parents){
newdata[[parent]] <- try(eval(parse(text = parent), envir = env), silent = T)
if(class(newdata[[parent]]) == "try-error"){
if(gam_fits[[parent]]$node_type == "parentless"){
assign(parent, do.call(f_parentless, list(sampling_vals = gam_fits[[parent]]$sampling_vals, N = N,
target_levels = gam_fits[[parent]]$target_levels), envir = env), pos = env)
} else if(gam_fits[[parent]]$node_type == "categorical") {
assign(parent, do.call(f_categorical, list(gam_model = gam_fits[[parent]]$gam_model,
parents = gam_fits[[parent]]$parents,
target_levels = gam_fits[[parent]]$target_levels,
N = N,
env = env), envir = env), pos = env)
} else if(gam_fits[[parent]]$node_type == "continuous"){
assign(parent, do.call(f_cont, list(gam_model = gam_fits[[parent]]$gam_model,
parents = gam_fits[[parent]]$parents,
N = N,
env = env), envir = env), pos = env)
}
newdata[[parent]] <- eval(parse(text = parent), envir = env)
}
}
newdata <- as.data.frame(newdata)
return(as.vector(predict(gam_model, newdata, type = "response")) + rnorm(n = nrow(newdata), sd = gam_model$sd))
}
for(var in vars){
if(!exists(var, envir = env)){
if(gam_fits[[var]]$node_type == "parentless"){
assign(var, do.call(f_parentless, list(sampling_vals = gam_fits[[var]]$sampling_vals, N = N,
target_levels = gam_fits[[var]]$target_levels)), pos = env)
} else if(gam_fits[[var]]$node_type == "categorical") {
assign(var, do.call(f_categorical, list(gam_model = gam_fits[[var]]$gam_model,
parents = gam_fits[[var]]$parents,
target_levels = gam_fits[[var]]$target_levels,
N = N,
env = env)), pos = env)
} else if(gam_fits[[var]]$node_type == "continuous"){
assign(var, do.call(f_cont, list(gam_model = gam_fits[[var]]$gam_model,
parents = gam_fits[[var]]$parents,
N = N,
env = env)), pos = env)
}
}
}
return(setNames(data.frame(lapply(vars, function(var) eval(parse(text = var)))), vars))
}
##################
library(carData)
data("GSSvocab")
GSSvocab <- GSSvocab %>% filter(complete.cases(.))
g <- dagitty("dag {
ageGroup [pos=\"0,0\"]
vocab [pos=\"1,-1\"]
nativeBorn [pos=\"2,-2\"]
educ [pos=\"3,-1\"]
gender [pos=\"4,0\"]
nativeBorn -> educ
nativeBorn -> vocab
educ -> vocab
gender -> educ
ageGroup -> vocab
}")
dag_model <- non_parametric_dag_model(dag = g, data = GSSvocab)
sim_data <- sim_mixed_dag(dag_model, N = 132)
library(dagitty); library(tidyverse); library(gam); library(mgcv)
parametric_dag_model <- function(dag, f.args = NULL){
if(is.null(f.args)) f.args <- setNames(vector(mode = "list", length = length(names(dag))), nm = names(dag))
if(sum(names(f.args) %in% names(dag)) < length(f.args)) stop("some variable entries in f.args don't match node names in supplied DAG")
if(sum(duplicated(names(f.args)))>0) stop("duplicate f.args variable entries")
vars <- names(dag)
parents <- setNames(lapply(vars, function(var) dagitty::parents(dag, var)), vars)
for(var in vars){
if(is.null(f.args[[var]]$link)) f.args[[var]]$link <- "identity"
if(!f.args[[var]]$link %in% c("identity", "quadratic", "exp", "cosin")) stop(paste0("link argument in f.args for variable ,", var,  " has to be one of identity, quadratic, exp, cosin"))
if(is.null(f.args[[var]]$levels)) f.args[[var]]$levels <- 1
if(is.null(f.args[[var]]$labels) & f.args[[var]]$levels > 1) f.args[[var]]$labels <- LETTERS[1:f.args[[var]]$levels]
if(is.null(f.args[[var]]$sinr)) f.args[[var]]$sinr <- 1
for(parent in parents[[var]]){
parent_levels <- f.args[[parent]]$levels
if(is.null(parent_levels)) f.args[[parent]]$levels <- 1
parent_betas <- f.args[[var]]$betas[[parent]]
if(is.null(parent_betas)) f.args[[var]]$betas[parent] <- setNames(list(if(f.args[[parent]]$levels > 1) rnorm(f.args[[parent]]$levels - 1) else rnorm(1)),
nm = parent)
}
}
ans <- list(dag = dag, f.args = f.args)
class(ans) <- "parametric_dag_model"
return(ans)
}
################################
sim_mixed_dag <- function(dag_model, ...) UseMethod("sim_mixed_dag")
sim_mixed_dag.parametric_dag_model <- function(dag_model, N = 1000, treatment_list = list()){
dag <- dag_model$dag; f.args <- dag_model$f.args
if(sum(names(f.args) %in% names(dag)) < length(f.args)) stop("some variable entries in f.args don't match node names in supplied DAG")
env = environment()
list2env(treatment_list, envir = env)
vars <- names(dag)
parents <- setNames(lapply(vars, function(var) dagitty::parents(dag, var)), vars)
if(sum(duplicated(names(f.args)))>0) stop("duplicate f.args variable entries")
f <- function(vars, link = "identity", levels = 1L, betas = NULL, labels = NULL, sinr = 1, env = NULL, result_var = NULL){
if(!link %in% c("identity", "quadratic", "exp", "cosin")) stop(paste0("link argument in f.args for variable \"", result_var, "\" has to be one of identity, quadratic, exp, cosin"))
lp <- rep(0, N)
for(var in vars){
var_val <- try(eval(parse(text = var), envir = parent.frame(1L)), silent = T)
if(class(var_val) == "try-error"){
assign(var, do.call(f, append(list(vars = parents[[var]], result_var = var), f.args[[var]])), envir = pos.to.env(-1L))
assign(var, eval(parse(text = var)), envir = env)
var_val <- eval(parse(text = var))
}
if(is.null(betas[[var]])){
beta <- as.matrix(if(is.factor(var_val)) rnorm(length(levels(var_val)) - 1) else rnorm(1))
} else {
beta <- as.matrix(betas[[var]])
}
X <- model.matrix(~ var_val - 1)
if(is.factor(var_val)) X <- X[, -1]
if(ncol(X) != nrow(beta)) stop(paste0("Number of levels in \"", var, "\" does not match number of input betas for that variable"))
lp <- lp + as.numeric(X %*% beta)
}
if(link == "quadratic") lp <- sign(lp)*lp^2
if(link == "cosin") lp <- cos(lp*2)
if(link == "exp") lp <- exp(lp)-1
if(var(lp) == 0){
lp <- lp + rnorm(length(lp), sd = 1) # add noise
} else {
lp <- lp + rnorm(length(lp), sd = sqrt(var(lp)/sinr)) # add noise
}
if(levels > 1){
if(is.null(labels)) labels <- LETTERS[1:levels]
if(length(labels) != levels) stop(paste0("labels do not match levels argument for variable \"", result_var, "\""))
lp <- lp/sd(lp)
thresh <- qnorm(p = seq(0, 1, length.out = levels + 1))
lp <- cut(lp, breaks = thresh, labels = labels, include.lowest = T)
}
return(lp)
}
for(var in vars){
if(!exists(var, envir = env)){
assign(var, do.call(f, append(list(vars = parents[[var]], env = env, result_var = var), f.args[[var]])), envir = env)
}
}
return(setNames(data.frame(lapply(vars, function(var) eval(parse(text = var)))), vars))
}
###################
get_ate <- function(dag_model, ...) UseMethod("get_ate")
get_ate.parametric_dag_model <- function(dag_model,  treatment = NULL, treatment_vals = NULL, exposure = NULL, N = 1000, M = 1000){
dag <- dag_model$dag; f.args <- dag_model$f.args
if(f.args[[exposure]]$levels > 2) stop("Exposure must be either numeric (levels = 1) or binary (levels = 2)")
if(is.null(treatment_vals)){
if(f.args[[treatment]]$levels == 1){
sample_treatment <- sim_mixed_dag(dag_model)[[treatment]]
treatment_vals <- unname(quantile(sample_treatment, seq(0.05, 0.95, by = 0.3)))
} else {
treatment_vals <- f.args[[treatment]]$labels
}
}
results <- matrix(ncol = length(treatment_vals), nrow = M)
ans <- data.frame(treatment_value = treatment_vals, ate = NA)
vars <- names(dag); vars <- vars[vars != treatment]
parents <- setNames(lapply(vars, function(var) dagitty::parents(dag, var)), vars)
env <- environment()
for(i in 1:length(treatment_vals)){
treatment_ls = setNames(list(rep(treatment_vals[i], N)), nm = treatment)
for(m in 1:M){
sim_data <- do.call(sim_mixed_dag, list(dag_model = dag_model, N = N, treatment_list = treatment_ls))
results[m, i] <- mean(sim_data[[exposure]])
}
}
ans$ate <- c(NA, diff(apply(results, 2, mean)))
return(ans)
}
####################
g <- dagitty("dag {
sales [pos=\"0,0\"]
mkt [pos=\"2,0\"]
comp [pos=\"1,1\"]
visits [pos=\"1,0\"]
visits -> sales
mkt -> visits
comp -> mkt
comp -> sales
}")
dag_model <- parametric_dag_model(dag = g, f.args = list(sales = list(betas = list(visits = 0.3, comp = -0.9)),
visits = list(betas = list(mkt = 0.5)),
mkt = list(betas = list(comp = 0.6))))
sim_data <- sim_mixed_dag(dag_model, N = 1432)
sim_data %>% ggplot(aes(comp, sales)) + geom_point() + stat_smooth(method = "lm")
# ate <- get_ate(dag_model = dag_model, treatment = "mkt", treatment_vals = seq(-2, 2), exposure = "sales")
# print(ate)
####################
non_parametric_dag_model <- function(dag, data){
if(mean(names(dag) %in% names(data)) != 1) stop("Some DAG nodes not found in data")
if(any(is.na(data))) stop("data contains missing values")
data <- data[names(dag)]
data <- data %>% mutate_if(is.character, factor) %>%
mutate_if(function(x) length(unique(x)) == 2, factor) # code 2 value variables as binary
vars <- names(dag)
ans <- setNames(object = vector(mode = "list", length = length(vars)), nm = vars)
for(var in vars){
var_parents <- parents(dag, var)
if(length(var_parents) == 0){
ans[[var]]$node_type <- "parentless"
sampling_vals <- tapply(data[[var]], data[[var]], length)/length(data[[var]])
sampling_vals <- data.frame(value = names(sampling_vals), freq = sampling_vals, row.names = NULL, stringsAsFactors = F)
if(is.numeric(data[[var]])) sampling_vals$value = as.numeric(sampling_vals$value)
ans[[var]]$sampling_vals <- sampling_vals
ans[[var]]$target_levels <- if(is.factor(data[[var]])) levels(data[[var]]) else NULL
} else {
ans[[var]]$parents <- var_parents
if(class(data[[var]]) == "factor") {
ans[[var]]$node_type <- "categorical"
forms <- lapply(unlist(strsplit(paste0(var, paste0(rep(paste0(" ~ ", paste0(sapply(var_parents, function(var_parent) {
if(class(data[[var_parent]]) == "factor") return(var_parent) else return(paste0("s(", var_parent, ")"))
}), collapse = " + ")), length(levels(data[[var]])) - 1), collapse = ", ")), ",")), as.formula)
ans[[var]]$target_levels <- levels(data[[var]])
num_levels <- length(levels(data[[var]]))
dat <- data[c(var, var_parents)]; dat[[var]] <- as.integer(dat[[var]]) - 1
ans[[var]]$gam_model <- gam(forms, family = if(num_levels == 2) "binomial" else multinom(K = num_levels - 1), data = dat)
} else {
ans[[var]]$node_type <- "continuous"
form <- as.formula(paste0(var, " ~ ", paste0(sapply(var_parents, function(var_parent) {
if(class(data[[var_parent]]) == "factor") return(var_parent) else return(paste0("s(", var_parent, ")"))
}), collapse = " + ")))
dat <- data[c(var, var_parents)]
ans[[var]]$gam_model <- gam(formula = form, family = "gaussian", data = dat)
ans[[var]]$gam_model$sd <- sd(dat[[var]])
}
}
}
ans <- list(dag = dag, gam_fits = ans)
class(ans) <- "non_parametric_dag_model"
return(ans)
}
#####################
sim_mixed_dag.non_parametric_dag_model <- function(dag_model,  N = 1000){
dag <- dag_model$dag; gam_fits <- dag_model$gam_fits
if(mean(names(gam_fits) %in% names(dag)) != 1 | length(names(dag)) != length(names(gam_fits))) stop("some variable entries in gam_fits don't match node names in supplied DAG")
env <- environment()
vars <- names(dag)
library(gam); library(mgcv)
f_parentless <- function(sampling_vals, target_levels = NULL, N) {
ans <- sample(x = sampling_vals[[1]], size = N, replace = T, prob = sampling_vals[[2]])
if(!is.null(target_levels)) ans <- factor(ans, levels = target_levels)
return(ans)
}
f_categorical <- function(gam_model, target_levels, parents, N, env){
newdata <- list()
for(parent in parents){
newdata[[parent]] <- try(eval(parse(text = parent), envir = env), silent = T)
if(class(newdata[[parent]]) == "try-error"){
if(gam_fits[[parent]]$node_type == "parentless"){
assign(parent, do.call(f_parentless, list(sampling_vals = gam_fits[[parent]]$sampling_vals, N = N,
target_levels = gam_fits[[parent]]$target_levels), envir = env), pos = env)
} else if(gam_fits[[parent]]$node_type == "categorical") {
assign(parent, do.call(f_categorical, list(gam_model = gam_fits[[parent]]$gam_model,
parents = gam_fits[[parent]]$parents,
target_levels = gam_fits[[parent]]$target_levels,
N = N,
env = env), envir = env), pos = env)
} else if(gam_fits[[parent]]$node_type == "continuous"){
assign(parent, do.call(f_cont, list(gam_model = gam_fits[[parent]]$gam_model,
parents = gam_fits[[parent]]$parents,
target_levels = gam_fits[[parent]]$target_levels,
N = N,
env = env), envir = env), pos = env)
}
newdata[[parent]] <- eval(parse(text = parent), envir = env)
}
}
newdata <- as.data.frame(newdata) %>% mutate_all(list(~replace(., is.na(.), sample(x = ., size = sum(is.na(.)), replace = T)))) # this shouldn't be needed
pred <- predict(gam_model, newdata, type = "response")
if(length(target_levels) == 2) {
return(target_levels[sapply(pred, function(p) rbinom(1, 1, p))])
} else {
return(factor(target_levels[apply(pred, 1, function(p_vec) which(rmultinom(1, 1, p_vec) == 1))], levels = target_levels))
}
}
f_cont <- function(gam_model, parents, N, env){
newdata <- list()
for(parent in parents){
newdata[[parent]] <- try(eval(parse(text = parent), envir = env), silent = T)
if(class(newdata[[parent]]) == "try-error"){
if(gam_fits[[parent]]$node_type == "parentless"){
assign(parent, do.call(f_parentless, list(sampling_vals = gam_fits[[parent]]$sampling_vals, N = N,
target_levels = gam_fits[[parent]]$target_levels), envir = env), pos = env)
} else if(gam_fits[[parent]]$node_type == "categorical") {
assign(parent, do.call(f_categorical, list(gam_model = gam_fits[[parent]]$gam_model,
parents = gam_fits[[parent]]$parents,
target_levels = gam_fits[[parent]]$target_levels,
N = N,
env = env), envir = env), pos = env)
} else if(gam_fits[[parent]]$node_type == "continuous"){
assign(parent, do.call(f_cont, list(gam_model = gam_fits[[parent]]$gam_model,
parents = gam_fits[[parent]]$parents,
N = N,
env = env), envir = env), pos = env)
}
newdata[[parent]] <- eval(parse(text = parent), envir = env)
}
}
newdata <- as.data.frame(newdata)
return(as.vector(predict(gam_model, newdata, type = "response")) + rnorm(n = nrow(newdata), sd = gam_model$sd))
}
for(var in vars){
if(!exists(var, envir = env)){
if(gam_fits[[var]]$node_type == "parentless"){
assign(var, do.call(f_parentless, list(sampling_vals = gam_fits[[var]]$sampling_vals, N = N,
target_levels = gam_fits[[var]]$target_levels)), pos = env)
} else if(gam_fits[[var]]$node_type == "categorical") {
assign(var, do.call(f_categorical, list(gam_model = gam_fits[[var]]$gam_model,
parents = gam_fits[[var]]$parents,
target_levels = gam_fits[[var]]$target_levels,
N = N,
env = env)), pos = env)
} else if(gam_fits[[var]]$node_type == "continuous"){
assign(var, do.call(f_cont, list(gam_model = gam_fits[[var]]$gam_model,
parents = gam_fits[[var]]$parents,
N = N,
env = env)), pos = env)
}
}
}
return(setNames(data.frame(lapply(vars, function(var) eval(parse(text = var)))), vars))
}
##################
library(carData)
data("GSSvocab")
GSSvocab <- GSSvocab %>% filter(complete.cases(.))
g <- dagitty("dag {
ageGroup [pos=\"0,0\"]
vocab [pos=\"1,-1\"]
nativeBorn [pos=\"2,-2\"]
educ [pos=\"3,-1\"]
gender [pos=\"4,0\"]
nativeBorn -> educ
nativeBorn -> vocab
educ -> vocab
gender -> educ
ageGroup -> vocab
}")
dag_model <- non_parametric_dag_model(dag = g, data = GSSvocab)
sim_data <- sim_mixed_dag(dag_model, N = 132)
source("../miscellaneous files/sim_mixed_dag2.R")
dag_model <- non_parametric_dag_model(dag = g, data = GSSvocab)
sim_data <- sim_mixed_dag(dag_model, N = 132)
